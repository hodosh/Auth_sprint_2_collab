# Flask app

## Описание
Сервис аутентификации и авторизации пользователей онлайн-кинотеатра.

## Используемый стек
 
- flask
- [apifairy](https://apifairy.readthedocs.io/en/latest/intro.html)
- SQLAlchemy
- flask-alembic
- flask-marshmallow
- flask-jwt-extended
- redis (в качестве хранилища отозванных токенов пользователя)
- PostgreSQL

## Особенности

### Токены
При создании сессии пользователю выдается новый токен, для закрытых энпоинтов вход осуществляется по токену в хедерах запроса.
При выходе из аккаунта токен отзывается.
Redis используется для хранения отозванных токенов, при запросе в эндпоинт, требующий доступ, токен проверяется на валидность.
Работа с рефреш-токенами производится так, что они пересоздают истекающий access-token пользователя, если сессия активна.
Время жизни access и refresh-токенов настраивается через параметры окружения ACCESS_EXPIRES_IN_HOURS, REFRESH_EXPIRES_IN_DAYS.
Доступ без токенов доступен только для ручки регистрации нового пользователя.

### Ролевой доступ
Доступ к энднпоинтам осуществляется по указанным эндпоинту пермишенам, 
для этого из токена берется информация по пользователю и проверяется значение у данного пользователя указанных пермишенов.
Если true, то доступ к энднпоинту имеется, иначе ошибка. 
Пермишены являются неизменяемыми значениями.
По умолчанию создаются 3 роли - user, superuser, non_registered.
При создании суперпользователя ему назначается роль superuser.

### Социальные сети
Реализован доступ к Google и Yandex.
Для логина с использованием внешних сервисов необходимо, чтобы email имелся в базе данных, тогда по запросу будет выдан токен,
в ином случае будет осуществлен переход на страницу регистрации, где необходимо завести email, совпадающий с тем, 
что указан во внешнем сервисе.
Для использования в незащищенных ресурсах (http://) устанавливается переменная окружения OAUTHLIB_INSECURE_TRANSPORT=1 

### Партицирование
Партицирование реализовано по платформе, из которой пришел запрос.
Платформа в запросе проверяется на соответствие списку имеющихся, если не соответствует,
то в таблицу UserHistory пишется значение other. Активность записывается только при авторизации/логине/логауте.
Для старых записей при миграции устанавливается значение other.

### Трассировка
Трассировка осуществляется при помощи модуля opentelemetry и Jaeger.
Для отключения при разработке (чтобы не было ошибок отсутствия в хедере X-Request-Id) 
устанавливается настройка TURN_OFF_TRACING=true. На проде она должна быть отключена. 

### Контракт
Фреймворк apifairy, используемый в качестве основного для данного api, готовит контракт автоматически, 
так как самостоятельно реализует сваггер.

### Интеграция и изящная деградация
Интеграция реализована следующим образом:
1) в Auth API добавлен эндпоинт валидации токена `/api/v1/users/check_access`.
2) В БД контента для таблицы фильмов добавлено булево поле premium (заполнено рандомно). 
3) в [Async API](https://github.com/hodosh/Async_API_sprint_2_collab) добавлена проверка наличия токена в хедере 
для эндпоинтов фильмов и валидация.
4) Деградация выполнена так, что если токен отсутствует или возникает ошибка при его проверке, 
то Async API исключает из запроса premium-контент, возвращая все, что остается.  
PR на доработки на стороне Async API - [тут](https://github.com/hodosh/Async_API_sprint_2_collab/pull/40)

### Схема базы данных
![](../img/db_schema.png)

### Сваггер
**Auth**
![](../img/auth_api.png)

**Users**
![](../img/users_api.png)

**Roles**
![](../img/roles_api.png)

## Запуск приложения без докера

### Требования к окружению

- Запущенный PostgreSQL
- Запущенный Redis

### Запуск

`flask run` в консоли в папке src

### Создание миграции

`flask db migrate -m "name"` Создает новую миграцию с именем name

### Применение миграции
`flask db upgrade` Применяет миграцию к базе данных

### Создание дефолтных ролей и пермишенов

`flask roles create`

Нужно сделать после начальной миграции, до создания суперпользователя

### Создание суперпользователя

`flask superuser create` далее ввести email и пароль в интерактивном режиме

## Запуск приложения в докере

!!! Создать сеть выполнением команды `docker network create -d bridge api`

**Prod** - docker-compose.yml

**Dev** - docker-compose-dev.yml (с дополнительным контейнером тестов)

**Local** - docker-compose-local.yml (для запуска только БД и Redis)

## Тесты
Тесты запускаются как локально, так и в компоузе `docker-compose-dev.yml`. Отчет формитуется в формате html.

### Авторы
Артур Махмутов - https://github.com/hodosh

Илья Суворкин - https://github.com/ilyavfx

Шамиль Хайдаров - https://github.com/hsh01
